## b753: P31以身分證投票之檢查
101年正式題術科 Problem 3：檢查碼問題 子題 1：身分證

中華民國身分證的號碼是經由一串公式所產生出來的，其身分證字號共有十碼，包括第一個大寫的英文字母與接續的九個阿拉伯數字。

(1)第一個碼代表地區，轉換方式為：A 轉換成1,0 兩個字元，B 轉換成1,1，餘如下：

A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z
10 11 12 13 14 15 16 17 34 18 19 20 21 22 35 23 24 25 26 27 28 29 32 30 31 33

(2)第二個碼代表性別，1 代表男性，2 代表女性

(3)第三個碼到第九個字元為流水號碼。

(4)第十個碼為檢查號碼。

例如：A123456789，其A 的轉換字元是1 和0，其餘各碼亦轉換成字元，依序存在 n1n2n3n4n5n6n7n8n9n10n11 的變數中，如右：然後再把每一個變數，依序乘上 1 9 8 7 6 5 4 3 2 1 及 1 的加權，再相加，如下：

n1×1+n2×9+n3×8+n4×7+n5×6+n6×5+n7×4+n8×3+n9×2+n10×1+n11×1

將身分證號碼 A123456789 套入公式，其結果為：

1x1 + 0x9 + 1x8 + 2x7 + 3x6 + 4x5 + 5x4 + 6x3 + 7x2 + 8x1 + 9x1 = 130

然後再除以 10，如果整除，該組身分證字號為有效。

假設今天有個活動，可以以有效的身分證字號進行投票，不限制本人使用，一個有效的身分證字號只能投票一次。請寫一支程式統計(1)有效的身分證字號和(2)有效的身分證字號但重複及(3)無效的身分證字號的個數。

每行的身分證字號將會為三種可能情況之一：

(1)有效的身分證字號：T

(2)有效的身分證字號但重複：O(有效的身分證字號第二次(含)之後再出現都列入重複)

(3)無效的身分證字號：F

分別計算T、O、F 的個數，並依序輸出其值。

例如在第一組測試資料中，有 8 筆資料：

M123456789(T) 2. A123456789(T) 3. A323456783(F)          4. M123456789(O)
M123456789(O) 6. M123456789(O) 7. A123456789(O)          8. A223344556(F)
例如在第二組測試資料中，有 4 筆資料：

R102345678 (T)、 2. A108881111(F) 、 3. A108881111(F) 、   4. B101111111(T)

## C
```C
#include<stdio.h>
#include<string.h>

int check(char []);

int main(void)
{
	int n;
	char id[10];
	
	while(scanf("%d", &n) != EOF)
	{
		int T = 0;
		int O = 0;
		int F = 0;
		char data[10][11];
			
		for(int i = 0; i < n; i++)
		{
			scanf("%s", id);

			int flag = 0;
			for(int j = 0; j < T; j++)
			{
				if(!(strcmp(id, data[j])))
				{
					O += 1;
					flag = 1;
					break;
				}
			}
			
			if(flag)
				continue;
			
			if(check(id))
			{
				strcpy(data[T], id);
				T += 1;
			}
			else
				F += 1;
		}
		
		printf("%d,%d,%d\n", T, O, F);
	}
	
	return 0;
}

int check(char str[])
{
	int area[26] = {10, 11, 12, 13, 14, 15, 16, 17, 34,
	            	18, 19, 20, 21, 22, 35, 23, 24, 25,
					26, 27, 28, 29, 32, 30, 31, 33};
	int verify = 0;
	int temp = area[str[0] - 'A'];
	
	verify += temp / 10 + (temp % 10) * 9;
	for(int i = 1; i < strlen(str); i++)
		verify += (str[i] - '0') * (9 - i);
		
	verify += str[strlen(str) - 1] - '0';
	
	return (str[1] == '1' || str[1] == '2') ? (!(verify % 10) ? 1 : 0) : 0;
}
```
 * Result : `AC (2ms, 92KB)`

## Python
